PROJECT DOCUMENTATION: 4-DOF ROBOTIC ARM FOR COOKING
====================================================

1. SYSTEM OVERVIEW
------------------
The project controls a 4-degree-of-freedom (4-DOF) robotic arm intended for cooking tasks. 
The architecture is split into two main components to maximize flexibility and debuggability:
   A. PC-SIDE (Brain): Python based GUI & Kinematics Engine.
   B. MCU-SIDE (Muscle): ESP32 Firmware acting as a hardware driver.

This separation allows for complex math and logging to happen on a powerful computer, 
while the ESP32 focuses solely on generating precise PWM signals.

2. HARDWARE ARCHITECTURE
------------------------
- **Controller**: ESP32 Development Board.
- **Actuators**: 
  - J1, J2, J3: TD-8120MG High Torque Servos (270° Range).
  - J4: Servomotor (Model TBD, check if 180° or 270°).
- **Connection**: USB Serial (UART) between PC and ESP32 at 115200 baud.
- **Power**: Servos should be powered by an external 5V-6V High Current supply, sharing GND with ESP32.

Pinout Configuration (Current):
- Servo 1 (Base/Waist) : GPIO 13
- Servo 2 (Shoulder)   : GPIO 14
- Servo 3 (Elbow)      : GPIO 22
- Servo 4 (Wrist/Tool) : GPIO 23

3. FIRMWARE (ESP32)
-------------------
**File:** `ESP32_FIRMWARE/simple_servo_control.ino`
**Role:** "Dumb" Driver.
**Logic:**
- It initializes 4 servo objects.
- It listens on the Serial port for text commands ending in a newline (`\n`).
- It parses these commands and updates the servo pulse width immediately.
- It does NOT perform any kinematics or geometric calculations.
- It enforces safety limits (Min Pulse: 500us, Max Pulse: 2500us).

**Communication Protocol:**
- **Command Format:** `s[ServoIndex]-[PulseWidth]`
  - `s1-1500`  -> Sets Servo 1 to 1500 microseconds.
  - `s3-600`   -> Sets Servo 3 to 600 microseconds.
  - `set`      -> Special command to center all servos to 1500us.
- **Feedback:** The ESP32 prints acknowledgement messages like `>> Servo 1 moved to 1500µs`.

4. SOFTWARE (PYTHON CONTROL)
----------------------------
**File:** `PYTHON_CONTROL/driver_gui.py` (and `visualize_robot.py`)
**Dependencies:** `tkinter`, `pyserial`, `numpy`, `matplotlib`
**Role:** The "Brain" - User Interface, Math, and Command Sender.

**Modules:**
A. **GUI (Graphical User Interface):**
   - Sliders for manual control (500-2500us).
   - Handles Serial connection.
   - Displays real-time logs and calculated XYZ positions.

B. **Kinematics Engine:**
   - **Input:** Current Pulse Widths.
   - **Process:** 
     1. Pulse -> Angle: using confirmed scale factors (0.135°/us for 270° servos).
     2. Angle -> Pose: using **Homogenous Transformation Matrices** (4x4).
   - **Output:** X, Y, Z coordinates of the tool tip.

C. **Visualizer (`visualize_robot.py`):**
   - A "Digital Twin" of the robot to verify geometric assumptions before writing control code.

7. KINEMATICS & GEOMETRY (Detailed Findings)
--------------------------------------------
A. Geometric Model Validation
   - A 3D visualization tool was created, and the user confirmed it matches the physical robot.
   - **Conclusion:** The robot acts as a chain of offset joints (not planar). Simple trigonometry (Law of Cosines) is insufficient/inaccurate. We will use Matrix Kinematics.
   - **Measurement Strategy:** The user is using STL files and Fusion 360's "Mesh Section Sketch" feature to extract the Theoretical Design Dimensions ($L_1, L_2$, Offsets), which is more accurate than physical caliper measurement.

B. Joint 4 (Wrist) Complexity
   - J4 rotates around the Z-axis (relative to the forearm).
   - The Tool Tip is offset in X, Y, and Z relative to the J4 axis.
   - **Critical Implication:** J4 is NOT just an orientation motor. Because of the offset, rotating J4 causes the tool tip to **orbit** in a circle. This changes the X,Y coordinates of the tip.
   - The IK solver must account for this "Orbital" behavior.

C. Servo Characteristics (TD-8120MG)
   - Range: 270 degrees over 2000us pulse delta (500-2500).
   - **Scale Factor:** 270.0 / 2000.0 = **0.135 degrees/us**.
   - Note: Standard servos use ~0.09 deg/us. Using the wrong factor results in massive position errors (e.g., commanding 90° yields 135°).

D. Calibration Strategy (Zeroing)
   - **Mechanical Zero:** The arm is assembled "roughly vertical" at neutral (1500us).
   - **Software Zero:** We will define "Angle 0" as the Perfect Vertical Pose.
   - **Procedure:**
     1. User uses GUI to jog robot until it is perfectly vertical (measured with square ruler).
     2. Validates J2 and J3 are straight up.
     3. These specific Pulse Values are saved as `ZERO_OFFSET_PULSE`.
     4. `Angle = (CurrentPulse - ZERO_OFFSET_PULSE) * 0.135`.
