PROJECT DOCUMENTATION: 4-DOF ROBOTIC ARM FOR COOKING
====================================================

1. SYSTEM OVERVIEW
------------------
The project controls a 4-degree-of-freedom (4-DOF) robotic arm intended for cooking tasks. 
The architecture is split into two main components to maximize flexibility and debuggability:
   A. PC-SIDE (Brain): Python based GUI & Kinematics Engine.
   B. MCU-SIDE (Muscle): ESP32 Firmware acting as a hardware driver.

This separation allows for complex math and logging to happen on a powerful computer, 
while the ESP32 focuses solely on generating precise PWM signals.

2. HARDWARE ARCHITECTURE
------------------------
- **Controller**: ESP32 Development Board.
- **Actuators**: 
  - J1, J2, J3: TD-8120MG High Torque Servos (270° Range).
  - J4: MG90S Micro Servo (180° Range).
- **Connection**: USB Serial (UART) between PC and ESP32 at 115200 baud.
- **Power**: Servos should be powered by an external 5V-6V High Current supply, sharing GND with ESP32.

Pinout Configuration (Current):
- Servo 1 (Base/Waist) : GPIO 13
- Servo 2 (Shoulder)   : GPIO 14
- Servo 3 (Elbow)      : GPIO 22
- Servo 4 (Wrist/Tool) : GPIO 23

3. FIRMWARE (ESP32)
-------------------
**File:** `ESP32_FIRMWARE/simple_servo_control.ino`
**Role:** "Dumb" Driver.
**Logic:**
- It initializes 4 servo objects.
- It listens on the Serial port for text commands ending in a newline (`\n`).
- It parses these commands and updates the servo pulse width immediately.
- It does NOT perform any kinematics or geometric calculations.
- It enforces safety limits (Min Pulse: 500us, Max Pulse: 2500us).

**Communication Protocol:**
- **Command Format:** `s[ServoIndex]-[PulseWidth]`
  - `s1-1500`  -> Sets Servo 1 to 1500 microseconds.
  - `s3-600`   -> Sets Servo 3 to 600 microseconds.
  - `set`      -> Special command to center all servos to 1500us.
- **Feedback:** The ESP32 prints acknowledgement messages like `>> Servo 1 moved to 1500µs`.

4. SOFTWARE (PYTHON CONTROL)
----------------------------
**File:** `Slider control with Forward kinematics/driver_gui.py` (and `visualize_robot.py`)
**Dependencies:** `tkinter`, `pyserial`, `numpy`, `matplotlib`
**Role:** The "Brain" - User Interface, Math, and Command Sender.

**Modules:**
A. **GUI (Graphical User Interface):**
   - Sliders for manual control (500-2500us).
   - Handles Serial connection.
   - Displays real-time logs and calculated XYZ positions.

B. **Kinematics Engine:**
   - **Input:** Current Pulse Widths.
   - **Process:** 
     1. Pulse -> Angle: using confirmed scale factors (0.135°/us for 270° servos).
     2. Angle -> Pose: using **Homogenous Transformation Matrices** (4x4).
   - **Output:** X, Y, Z coordinates of the tool tip.

C. **Visualizer (`visualize_robot.py`):**
   - A "Digital Twin" of the robot to verify geometric assumptions before writing control code.

7. KINEMATICS & GEOMETRY (Detailed Findings)
--------------------------------------------
A. Geometric Model Validation
   - A 3D visualization tool was created, and the user confirmed it matches the physical robot.
   - **Conclusion:** The robot acts as a chain of offset joints (not planar). Simple trigonometry (Law of Cosines) is insufficient/inaccurate. We will use Matrix Kinematics.
   - **Measurement Strategy:** The user is using STL files and Fusion 360's "Mesh Section Sketch" feature to extract the Theoretical Design Dimensions ($L_1, L_2$, Offsets), which is more accurate than physical caliper measurement.

B. Joint 4 (Wrist) Complexity
   - J4 rotates around the Z-axis (relative to the forearm).
   - The Tool Tip is offset in X, Y, and Z relative to the J4 axis.
   - **Critical Implication:** J4 is NOT just an orientation motor. Because of the offset, rotating J4 causes the tool tip to **orbit** in a circle. This changes the X,Y coordinates of the tip.
   - The IK solver must account for this "Orbital" behavior.

C. Servo Characteristics
   - **J1, J2, J3 (TD-8120MG):** 
     - Range: 270 degrees.
     - Scale Factor: **0.135 degrees/us**.
   - **J4 (MG90S):**
     - Range: 180 degrees.
     - Scale Factor: **0.09 degrees/us**.
     - Note: This was identified during testing where J4 angles were significantly overestimated by the 270-degree logic.

D. Calibration Strategy (Zeroing)
   - **Mechanical Zero:** The arm is assembled "roughly vertical" at neutral (1500us).
   - **Software Zero:** We will define "Angle 0" as the Perfect Vertical Pose.
   - **Procedure:**
     1. User uses GUI to jog robot until it is perfectly vertical (measured with square ruler).
     2. Validates J2 and J3 are straight up.
     3. These specific Pulse Values are saved as `ZERO_OFFSET_PULSE`.
     4. `Angle = (CurrentPulse - ZERO_OFFSET_PULSE) * 0.135`.

E. Calibration Results (Jan 8, 2026 - Inverse Kinematic Implementation)
   **Phase 1: Angle Display Fix**
   - **Problem:** GUI showed 1526.3° for J2 when servo was at physical 0°
   - **Root Cause:** Incorrect DEFAULT_TRIMS and JOINT_OFFSETS from previous calibration
   - **Solution:** Reset both to zero and recalibrated from scratch
   - **Result:** Angles now display correctly
   
   **Phase 2: Trim Calibration (Pulse Width Level)**
   - **Goal:** Find pulse width where J2 is at true vertical (0°)
   - **Method:** Adjusted slider until physical servo was vertical
   - **Result:** J2 requires 1529µs to be at true 0°
   - **Configuration:** DEFAULT_TRIMS[1] = 29
   - **Formula:** Neutral_Pulse = 1500 + 29 = 1529µs
   
   **Phase 3: Geometric Offset Calibration (Angle Level)**
   - **Problem:** When GUI shows 85.7° for J2, physical measurement shows 90° (horizontal)
   - **Problem:** At -90°, the calibration is accurate (no offset needed)
   - **Analysis:** This asymmetry suggests either:
     * Servo mounting isn't perfectly aligned with robot geometry
     * Physical construction has slight angular deviation
     * Mechanical compliance/flex at positive angles
   - **Solution:** Add JOINT_OFFSETS[1] = 4.3°
   - **Calculation:** Physical_Angle - GUI_Angle = 90.0 - 85.7 = 4.3°
   - **Formula:** Final_Angle = (Calculated_Angle × Direction) + Offset
   - **Result:** GUI now reads 90.0° when physical measurement confirms horizontal
   
   **Understanding the Two-Stage Calibration:**
   1. **DEFAULT_TRIMS** (Stage 1): Shifts the pulse-to-angle conversion neutral point
      - Works at the pulse width level (microseconds)
      - Corrects for servo centering variations
      - J2 Example: 1529µs is true mechanical zero, not 1500µs
      
   2. **JOINT_OFFSETS** (Stage 2): Compensates for geometric misalignment
      - Works at the angle level (degrees)
      - Corrects for mounting angles or design deviations
      - J2 Example: +4.3° added to account for geometric reality vs. ideal model
   
   **Final J2 Calibration:**
   - DEFAULT_TRIMS[1] = 29 (pulse width correction)
   - JOINT_OFFSETS[1] = 4.3 (geometric correction)
   - JOINT_DIRECTIONS[1] = 1 (normal direction)
   
   **Trade-off and Precision Limitation:**
   - With JOINT_OFFSETS[1] = 4.3°, the +90° position is accurate
   - However, this offset causes -90° to read incorrectly (now reads ~-85.7°)
   - **Root Cause:** The physical robot exhibits asymmetric behavior - likely due to:
     * Mechanical compliance/flex under gravity (arm weight pulls differently at +90° vs -90°)
     * Servo mounting angle not perfectly perpendicular to rotation axis
     * Structural deflection or joint play that varies with direction
   - **Practical Solution:** For maximum precision in inverse kinematics operations:
     * **AVOID negative J2 angles** (below 0°)
     * **USE positive J2 angles only** (0° to +90° range)
     * This ensures kinematics accuracy matches physical reality
     * Trade-off accepted: Workspace is reduced but precision is maintained
   - **Alternative (not implemented):** Could use non-linear calibration curves or 
     direction-dependent offsets, but adds complexity for marginal benefit

8. SAFETY SYSTEMS (Post-Incident Implementation - Jan 8, 2026)
--------------------------------------------------------------
A. Incident Summary (Jan 7, 2026)
   - During IK testing, robot commanded to unreachable/blocked position
   - Open-loop system (no feedback) assumed servo reached target
   - Metal-gear servo overpowered plastic spline in servo horn
   - Result: Stripped spline, arm slips, calibration invalidated
   
B. Root Causes Identified
   1. No collision detection with base structure
   2. No path planning (direct trajectories)
   3. No current limiting on power supply
   4. No emergency stop mechanism
   5. Open-loop control without position verification

C. Implemented Software Safety Measures
   
   **1. Cylindrical Base Collision Detection**
   - Base parameters: Radius = 30.3125mm, Height = 61mm
   - Function: check_collision_with_base(x, y, z)
   - Checks if any point intersects with cylindrical base volume
   - Base centered at origin (0, 0, 0) of cartesian frame
   
   **2. Path Collision Checking**
   - Function: check_path_collision(start_pulses, end_pulses, num_samples=20)
   - Samples 20 points along linear interpolation in pulse space
   - Computes FK for each sample point
   - Checks each point for base collision
   - Returns collision point if detected
   
   **3. ESSENTIAL: Safe Move Protocol**
   - Function: safe_move_to_target(target_x, target_y, target_z, current_pulses)
   - Implements two-step movement strategy:
     STEP 1: Always return to HOME position (all angles 0°, vertical)
     STEP 2: Move from HOME to target position
   - Rationale:
     * Predictable, repeatable trajectories
     * Avoids complex path planning
     * Sufficient for cooking tasks (pancakes)
     * Vertical position guarantees base clearance
   
   **4. Pre-Movement Validation**
   - Check 1: Target itself not in collision
   - Check 2: Path from current → home is collision-free
   - Check 3: IK converges for target (error < 1mm)
   - Check 4: Path from home → target is collision-free
   - If ANY check fails, movement is ABORTED with detailed error
   
   **5. GUI Integration**
   - "Move To Target" button now uses safe_move_to_target()
   - Logs show validation results before movement
   - 2-second delay between home and target moves
   - Status indicators:
     * Blue: "Moving via HOME" - in progress
     * Green: "Success" - completed
     * Red: "BLOCKED" - validation failed

D. Required Hardware Safety Measures (From Incident Report)
   
   **1. Current Limiting (ESSENTIAL)**
   - Limit power supply to 3A maximum
   - Method: Use lab power supply with current limit feature
   - Alternative: Add 3A fuse in series with servo power
   - Prevents mechanical damage if servo stalls
   
   **2. Emergency Stop Button (ESSENTIAL)**
   - Physical red button with LED indicator
   - Hold in hand during operation
   - Cuts power to servos immediately
   - Required for all testing and operation
   
   **3. Mechanical Upgrades**
   - Replace plastic servo horns with metal (aluminum 25T)
   - Status: Plastic horn replaced (temporary fix)
   - Permanent solution: Metal horns for all high-torque joints
   
   **4. Visual Trajectory Preview (Recommended)**
   - Matplotlib visualization of planned path before execution
   - Shows: Current pose → Home → Target
   - User confirms before robot moves
   - Not yet implemented

E. Operational Guidelines for Safe Usage
   1. Always limit power supply current to 3A
   2. Keep emergency stop button in hand
   3. Verify home position after power-on
   4. Use positive J2 angles only (0° to +90°)
   5. Start with small, slow movements to verify calibration
   6. Never command positions near workspace limits
   7. Monitor servo temperatures during operation
   8. If any unusual sound/resistance: STOP immediately

F. Future Enhancements Under Discussion
   1. Add 5th DOF to improve trajectory flexibility
   2. Implement smooth trajectory interpolation (splines)
   3. Real-time servo position feedback (close the loop)
   4. Force/torque sensing at joints
   5. 3D workspace visualization with matplotlib
   6. Automatic workspace boundary enforcement

9. INVERSE KINEMATICS ALGORITHM IMPLEMENTATION & DEBUGGING (Jan 8, 2026)
------------------------------------------------------------------------

A. Initial Implementation - Numerical Jacobian Method
   
   **Algorithm Type:** Iterative Numerical Inverse Kinematics
   - Method: Gradient Descent with Numerical Jacobian
   - Jacobian Computation: Finite difference approximation (ε = 1.0 µs)
   - Step Update: delta_pulses = pinv(J) × error_vector
   
   **Original Parameters:**
   - Learning rate (α): 0.5
   - Max iterations: 50
   - Convergence tolerance: 1.0mm
   - Pulse limits: [500, 2500] µs
   
   **How It Works:**
   1. Start with initial pulse guess (home position or current position)
   2. Compute forward kinematics → current position (x, y, z)
   3. Calculate error vector: error = target - current
   4. Compute numerical Jacobian J (3×4 matrix):
      - For each joint i, perturb pulse by ε
      - J[:, i] = (FK(pulse + ε) - FK(pulse)) / ε
   5. Solve: J × Δpulse = error using pseudo-inverse
   6. Update: pulse = pulse + α × Δpulse
   7. Clamp pulses to [500, 2500] range
   8. Repeat until error < tolerance or max iterations reached

B. Critical Failure Case Discovery
   
   **Test Scenario (Jan 8, 2026):**
   - Target Position: (-0.81, -195.07, 1.22) mm
   - Initial Guess: Home position [1500, 1529, 1500, 1500]
   - User manually reached this position successfully
   - Physical servo readings: J2≈2125, J3≈1088
   
   **Failure Symptoms:**
   - IK failed to converge after 50 iterations
   - Final error: 50.20mm
   - Final pulses: [1537, 2500, 1980, 561]
   - J2 hit upper limit (2500), J4 hit lower limit (561)
   - Achieved position: (-1.45, -205.69, 49.96) mm
   - Error in Z-axis: 48.74mm (wanted 1.22mm, got 49.96mm)
   
   **Root Causes Identified:**
   
   1. **Excessive Learning Rate (α = 0.5)**
      - Too aggressive steps caused oscillation
      - Algorithm overshot optimal solutions
      - Accumulated error instead of converging
   
   2. **Joint Limit Saturation**
      - Pulses clamped at limits without algorithm awareness
      - Continued attempting moves in saturated directions
      - Got stuck in local minima when joints maxed out
      - No recovery mechanism from limit conditions
   
   3. **No Step Quality Check**
      - Accepted all steps regardless of improvement
      - Could increase error and still proceed
      - No backtracking when moves worsened position
   
   4. **Ill-Conditioned Jacobian**
      - Pure pseudo-inverse unstable near singularities
      - Small changes in joint angles → large position changes
      - Numerical instability accumulated over iterations
   
   5. **Insufficient Iterations**
      - 50 iterations inadequate for difficult targets
      - Especially from home position to extreme workspace edges

C. Improved Algorithm - Damped Least Squares with Adaptive Step Size
   
   **New Algorithm Components:**
   
   1. **Damped Least Squares (Levenberg-Marquardt style)**
      - Replaces pure pseudo-inverse: pinv(J)
      - New formulation: (J^T × J + λI)^-1 × J^T × error
      - Damping factor λ = 0.01
      - Benefits:
        * More stable near singularities
        * Prevents large jumps from small Jacobian values
        * Regularizes ill-conditioned systems
        * Smoother convergence trajectory
   
   2. **Adaptive Learning Rate**
      - Initial α = 0.1 (5× smaller than original)
      - Dynamic adjustment based on progress:
        * If error decreases: α = min(0.5, α × 1.1) [speed up]
        * If error increases: α = α × 0.5 [slow down]
        * Minimum α = 0.001 (prevents complete stall)
      - Allows fast convergence when going well
      - Provides stability when approaching solution
   
   3. **Line Search / Step Validation**
      - Computes proposed_pulses = current + α × delta
      - Evaluates FK at proposed position
      - Compares proposed_error vs current_error
      - Only accepts step if error decreases
      - Rejects bad steps and reduces α automatically
      - Prevents divergence and oscillation
   
   4. **Increased Iteration Budget**
      - Max iterations: 50 → 200
      - Provides more attempts for difficult configurations
      - Allows convergence from poor initial guesses
      - Particularly important for extreme workspace positions
   
   **Implementation Code Structure:**
   ```
   alpha = 0.1  # Initial step size
   damping = 0.01
   
   for iteration in range(max_iter):
       # 1. Compute current position & error
       current_pos = FK(pulses)
       error_vec = target - current_pos
       
       # 2. Build numerical Jacobian
       J = compute_jacobian(pulses)
       
       # 3. Solve using Damped Least Squares
       JtJ = J.T @ J
       delta = solve(JtJ + damping*I, J.T @ error)
       
       # 4. Propose step with clamping
       proposed = clamp(pulses + alpha * delta)
       
       # 5. Validate step (line search)
       if error(proposed) < error(current):
           pulses = proposed
           alpha = min(0.5, alpha * 1.1)  # Speed up
       else:
           alpha = max(0.001, alpha * 0.5)  # Slow down
   ```

D. Verification Results
   
   **Same Test Case Re-run:**
   - Target: (-0.81, -195.07, 1.22) mm
   - Initial: Home [1500, 1529, 1500, 1500]
   
   **New Results:**
   ✓ SUCCESS: Converged in 24 iterations
   ✓ Final error: 0.79mm (well below 1.0mm tolerance)
   ✓ Final pulses: [1500, 2121, 1084, 1470]
   ✓ Achieved position: (-0.58, -194.46, 1.93) mm
   
   **Performance Comparison:**
   | Metric              | Original | Improved | Change      |
   |---------------------|----------|----------|-------------|
   | Convergence         | Failed   | Success  | ✓ Fixed     |
   | Iterations          | 50       | 24       | 52% faster  |
   | Final Error         | 50.20mm  | 0.79mm   | 98% better  |
   | J2 Pulse            | 2500*    | 2121     | Not limited |
   | J4 Pulse            | 561*     | 1470     | Not limited |
   
   *Original hit joint limits
   
   **Accuracy Verification:**
   - Manual servo position: J2≈2125, J3≈1088
   - IK computed position:  J2=2121, J3=1084
   - Difference: J2 = 4µs, J3 = 4µs
   - Excellent agreement with physical reality!

E. Algorithm Characteristics & Performance
   
   **Convergence Properties:**
   - Monotonic error reduction (always improves or maintains)
   - No oscillation around solution
   - Stable near joint limits
   - Handles singularities gracefully
   - Robust to poor initial guesses
   
   **Computational Cost:**
   - Per iteration: 5 forward kinematics calls
     * 1 for current position
     * 4 for Jacobian columns (one per joint)
   - Typical convergence: 20-30 iterations
   - Total FK calls: ~100-150 per IK solve
   - Execution time: <50ms on modern CPU
   
   **Limitations & Constraints:**
   - Still requires reasonable initial guess (within ~100mm of solution)
   - Cannot find solutions outside joint limits
   - May converge to local minima in multi-solution cases
   - Does not guarantee global optimum
   - Assumes continuous, differentiable workspace
   
   **When IK Fails (Error > 1mm):**
   - Target physically unreachable (outside workspace)
   - Target requires joints beyond [500, 2500]µs limits
   - Target in singularity configuration
   - Starting guess too far from any solution
   
F. Practical Usage Guidelines
   
   **For Best Results:**
   1. Provide current position as initial guess when available
   2. Use home position for new targets if current unknown
   3. Avoid targets at extreme workspace boundaries
   4. Stay clear of singularities (arm fully extended/retracted)
   5. Verify target reachability before commanding
   
   **Debugging Failed IK:**
   1. Check FK of final pulses → see where it ended up
   2. Verify target is within physical workspace
   3. Try different initial guess (current vs home)
   4. Increase max_iter if close but not converged
   5. Reduce tolerance if 1mm is too strict
   
   **Integration with Safe Move:**
   - safe_move_to_target() always uses home as IK starting point
   - Ensures consistent, repeatable convergence
   - Two-step path: current → home → target
   - IK computed once for target (from home)
   - Path collision checked separately

G. Mathematical Background (For Reference)
   
   **Jacobian Matrix J:**
   - Maps joint velocity space to Cartesian velocity space
   - J ∈ ℝ³ˣ⁴ (3 Cartesian DOF, 4 joint DOF)
   - Element J[i,j] = ∂(position_i)/∂(pulse_j)
   - Numerical approximation: J[i,j] ≈ (FK(p+ε·ej) - FK(p))[i] / ε
   
   **Pseudo-Inverse Method:**
   - Standard: Δp = J⁺ × e, where J⁺ = (J^T×J)⁻¹×J^T
   - Problem: Singular when J^T×J is rank-deficient
   - Unstable when eigenvalues of J^T×J are small
   
   **Damped Least Squares:**
   - Modified: Δp = (J^T×J + λI)⁻¹ × J^T × e
   - Damping term λI adds to diagonal
   - Ensures J^T×J + λI is always invertible
   - λ controls trade-off: accuracy vs stability
   - As λ→0: approaches pseudo-inverse (fast, unstable)
   - As λ→∞: approaches gradient descent (slow, stable)
   - Optimal λ ≈ 0.01 found empirically
   
   **Convergence Criterion:**
   - Success: ||target - FK(pulses)|| < tolerance
   - Failure: iterations ≥ max_iter and error ≥ tolerance
   - Typical convergence rate: exponential initially, linear near solution
