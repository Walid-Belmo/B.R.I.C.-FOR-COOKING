PROJECT DOCUMENTATION: 4-DOF ROBOTIC ARM FOR COOKING
====================================================

1. SYSTEM OVERVIEW
------------------
The project controls a 4-degree-of-freedom (4-DOF) robotic arm intended for cooking tasks. 
The architecture is split into two main components to maximize flexibility and debuggability:
   A. PC-SIDE (Brain): Python based GUI & Kinematics Engine.
   B. MCU-SIDE (Muscle): ESP32 Firmware acting as a hardware driver.

This separation allows for complex math and logging to happen on a powerful computer, 
while the ESP32 focuses solely on generating precise PWM signals.

2. HARDWARE ARCHITECTURE
------------------------
- **Controller**: ESP32 Development Board.
- **Actuators**: 
  - J1, J2, J3: TD-8120MG High Torque Servos (270° Range).
  - J4: MG90S Micro Servo (180° Range).
- **Connection**: USB Serial (UART) between PC and ESP32 at 115200 baud.
- **Power**: Servos should be powered by an external 5V-6V High Current supply, sharing GND with ESP32.

Pinout Configuration (Current):
- Servo 1 (Base/Waist) : GPIO 13
- Servo 2 (Shoulder)   : GPIO 14
- Servo 3 (Elbow)      : GPIO 22
- Servo 4 (Wrist/Tool) : GPIO 23

3. FIRMWARE (ESP32)
-------------------
**File:** `ESP32_FIRMWARE/simple_servo_control.ino`
**Role:** "Dumb" Driver.
**Logic:**
- It initializes 4 servo objects.
- It listens on the Serial port for text commands ending in a newline (`\n`).
- It parses these commands and updates the servo pulse width immediately.
- It does NOT perform any kinematics or geometric calculations.
- It enforces safety limits (Min Pulse: 500us, Max Pulse: 2500us).

**Communication Protocol:**
- **Command Format:** `s[ServoIndex]-[PulseWidth]`
  - `s1-1500`  -> Sets Servo 1 to 1500 microseconds.
  - `s3-600`   -> Sets Servo 3 to 600 microseconds.
  - `set`      -> Special command to center all servos to 1500us.
- **Feedback:** The ESP32 prints acknowledgement messages like `>> Servo 1 moved to 1500µs`.

4. SOFTWARE (PYTHON CONTROL)
----------------------------
**File:** `Slider control with Forward kinematics/driver_gui.py` (and `visualize_robot.py`)
**Dependencies:** `tkinter`, `pyserial`, `numpy`, `matplotlib`
**Role:** The "Brain" - User Interface, Math, and Command Sender.

**Modules:**
A. **GUI (Graphical User Interface):**
   - Sliders for manual control (500-2500us).
   - Handles Serial connection.
   - Displays real-time logs and calculated XYZ positions.

B. **Kinematics Engine:**
   - **Input:** Current Pulse Widths.
   - **Process:** 
     1. Pulse -> Angle: using confirmed scale factors (0.135°/us for 270° servos).
     2. Angle -> Pose: using **Homogenous Transformation Matrices** (4x4).
   - **Output:** X, Y, Z coordinates of the tool tip.

C. **Visualizer (`visualize_robot.py`):**
   - A "Digital Twin" of the robot to verify geometric assumptions before writing control code.

7. KINEMATICS & GEOMETRY (Detailed Findings)
--------------------------------------------
A. Geometric Model Validation
   - A 3D visualization tool was created, and the user confirmed it matches the physical robot.
   - **Conclusion:** The robot acts as a chain of offset joints (not planar). Simple trigonometry (Law of Cosines) is insufficient/inaccurate. We will use Matrix Kinematics.
   - **Measurement Strategy:** The user is using STL files and Fusion 360's "Mesh Section Sketch" feature to extract the Theoretical Design Dimensions ($L_1, L_2$, Offsets), which is more accurate than physical caliper measurement.

B. Joint 4 (Wrist) Complexity
   - J4 rotates around the Z-axis (relative to the forearm).
   - The Tool Tip is offset in X, Y, and Z relative to the J4 axis.
   - **Critical Implication:** J4 is NOT just an orientation motor. Because of the offset, rotating J4 causes the tool tip to **orbit** in a circle. This changes the X,Y coordinates of the tip.
   - The IK solver must account for this "Orbital" behavior.

C. Servo Characteristics
   - **J1, J2, J3 (TD-8120MG):** 
     - Range: 270 degrees.
     - Scale Factor: **0.135 degrees/us**.
   - **J4 (MG90S):**
     - Range: 180 degrees.
     - Scale Factor: **0.09 degrees/us**.
     - Note: This was identified during testing where J4 angles were significantly overestimated by the 270-degree logic.

D. Calibration Strategy (Zeroing)
   - **Mechanical Zero:** The arm is assembled "roughly vertical" at neutral (1500us).
   - **Software Zero:** We will define "Angle 0" as the Perfect Vertical Pose.
   - **Procedure:**
     1. User uses GUI to jog robot until it is perfectly vertical (measured with square ruler).
     2. Validates J2 and J3 are straight up.
     3. These specific Pulse Values are saved as `ZERO_OFFSET_PULSE`.
     4. `Angle = (CurrentPulse - ZERO_OFFSET_PULSE) * 0.135`.

E. Calibration Results (Jan 8, 2026 - Inverse Kinematic Implementation)
   **Phase 1: Angle Display Fix**
   - **Problem:** GUI showed 1526.3° for J2 when servo was at physical 0°
   - **Root Cause:** Incorrect DEFAULT_TRIMS and JOINT_OFFSETS from previous calibration
   - **Solution:** Reset both to zero and recalibrated from scratch
   - **Result:** Angles now display correctly
   
   **Phase 2: Trim Calibration (Pulse Width Level)**
   - **Goal:** Find pulse width where J2 is at true vertical (0°)
   - **Method:** Adjusted slider until physical servo was vertical
   - **Result:** J2 requires 1529µs to be at true 0°
   - **Configuration:** DEFAULT_TRIMS[1] = 29
   - **Formula:** Neutral_Pulse = 1500 + 29 = 1529µs
   
   **Phase 3: Geometric Offset Calibration (Angle Level)**
   - **Problem:** When GUI shows 85.7° for J2, physical measurement shows 90° (horizontal)
   - **Problem:** At -90°, the calibration is accurate (no offset needed)
   - **Analysis:** This asymmetry suggests either:
     * Servo mounting isn't perfectly aligned with robot geometry
     * Physical construction has slight angular deviation
     * Mechanical compliance/flex at positive angles
   - **Solution:** Add JOINT_OFFSETS[1] = 4.3°
   - **Calculation:** Physical_Angle - GUI_Angle = 90.0 - 85.7 = 4.3°
   - **Formula:** Final_Angle = (Calculated_Angle × Direction) + Offset
   - **Result:** GUI now reads 90.0° when physical measurement confirms horizontal
   
   **Understanding the Two-Stage Calibration:**
   1. **DEFAULT_TRIMS** (Stage 1): Shifts the pulse-to-angle conversion neutral point
      - Works at the pulse width level (microseconds)
      - Corrects for servo centering variations
      - J2 Example: 1529µs is true mechanical zero, not 1500µs
      
   2. **JOINT_OFFSETS** (Stage 2): Compensates for geometric misalignment
      - Works at the angle level (degrees)
      - Corrects for mounting angles or design deviations
      - J2 Example: +4.3° added to account for geometric reality vs. ideal model
   
   **Final J2 Calibration:**
   - DEFAULT_TRIMS[1] = 29 (pulse width correction)
   - JOINT_OFFSETS[1] = 4.3 (geometric correction)
   - JOINT_DIRECTIONS[1] = 1 (normal direction)
   
   **Trade-off and Precision Limitation:**
   - With JOINT_OFFSETS[1] = 4.3°, the +90° position is accurate
   - However, this offset causes -90° to read incorrectly (now reads ~-85.7°)
   - **Root Cause:** The physical robot exhibits asymmetric behavior - likely due to:
     * Mechanical compliance/flex under gravity (arm weight pulls differently at +90° vs -90°)
     * Servo mounting angle not perfectly perpendicular to rotation axis
     * Structural deflection or joint play that varies with direction
   - **Practical Solution:** For maximum precision in inverse kinematics operations:
     * **AVOID negative J2 angles** (below 0°)
     * **USE positive J2 angles only** (0° to +90° range)
     * This ensures kinematics accuracy matches physical reality
     * Trade-off accepted: Workspace is reduced but precision is maintained
   - **Alternative (not implemented):** Could use non-linear calibration curves or 
     direction-dependent offsets, but adds complexity for marginal benefit

8. SAFETY SYSTEMS (Post-Incident Implementation - Jan 8, 2026)
--------------------------------------------------------------
A. Incident Summary (Jan 7, 2026)
   - During IK testing, robot commanded to unreachable/blocked position
   - Open-loop system (no feedback) assumed servo reached target
   - Metal-gear servo overpowered plastic spline in servo horn
   - Result: Stripped spline, arm slips, calibration invalidated
   
B. Root Causes Identified
   1. No collision detection with base structure
   2. No path planning (direct trajectories)
   3. No current limiting on power supply
   4. No emergency stop mechanism
   5. Open-loop control without position verification

C. Implemented Software Safety Measures
   
   **1. Cylindrical Base Collision Detection**
   - Base parameters: Radius = 30.3125mm, Height = 61mm
   - Function: check_collision_with_base(x, y, z)
   - Checks if any point intersects with cylindrical base volume
   - Base centered at origin (0, 0, 0) of cartesian frame
   
   **2. Path Collision Checking**
   - Function: check_path_collision(start_pulses, end_pulses, num_samples=20)
   - Samples 20 points along linear interpolation in pulse space
   - Computes FK for each sample point
   - Checks each point for base collision
   - Returns collision point if detected
   
   **3. ESSENTIAL: Safe Move Protocol**
   - Function: safe_move_to_target(target_x, target_y, target_z, current_pulses)
   - Implements two-step movement strategy:
     STEP 1: Always return to HOME position (all angles 0°, vertical)
     STEP 2: Move from HOME to target position
   - Rationale:
     * Predictable, repeatable trajectories
     * Avoids complex path planning
     * Sufficient for cooking tasks (pancakes)
     * Vertical position guarantees base clearance
   
   **4. Pre-Movement Validation**
   - Check 1: Target itself not in collision
   - Check 2: Path from current → home is collision-free
   - Check 3: IK converges for target (error < 1mm)
   - Check 4: Path from home → target is collision-free
   - If ANY check fails, movement is ABORTED with detailed error
   
   **5. GUI Integration**
   - "Move To Target" button now uses safe_move_to_target()
   - Logs show validation results before movement
   - 2-second delay between home and target moves
   - Status indicators:
     * Blue: "Moving via HOME" - in progress
     * Green: "Success" - completed
     * Red: "BLOCKED" - validation failed

D. Required Hardware Safety Measures (From Incident Report)
   
   **1. Current Limiting (ESSENTIAL)**
   - Limit power supply to 3A maximum
   - Method: Use lab power supply with current limit feature
   - Alternative: Add 3A fuse in series with servo power
   - Prevents mechanical damage if servo stalls
   
   **2. Emergency Stop Button (ESSENTIAL)**
   - Physical red button with LED indicator
   - Hold in hand during operation
   - Cuts power to servos immediately
   - Required for all testing and operation
   
   **3. Mechanical Upgrades**
   - Replace plastic servo horns with metal (aluminum 25T)
   - Status: Plastic horn replaced (temporary fix)
   - Permanent solution: Metal horns for all high-torque joints
   
   **4. Visual Trajectory Preview (Recommended)**
   - Matplotlib visualization of planned path before execution
   - Shows: Current pose → Home → Target
   - User confirms before robot moves
   - Not yet implemented

E. Operational Guidelines for Safe Usage
   1. Always limit power supply current to 3A
   2. Keep emergency stop button in hand
   3. Verify home position after power-on
   4. Use positive J2 angles only (0° to +90°)
   5. Start with small, slow movements to verify calibration
   6. Never command positions near workspace limits
   7. Monitor servo temperatures during operation
   8. If any unusual sound/resistance: STOP immediately

F. Future Enhancements Under Discussion
   1. Add 5th DOF to improve trajectory flexibility
   2. Implement smooth trajectory interpolation (splines)
   3. Real-time servo position feedback (close the loop)
   4. Force/torque sensing at joints
   5. 3D workspace visualization with matplotlib
   6. Automatic workspace boundary enforcement
