PROJECT DOCUMENTATION: 4-DOF ROBOTIC ARM FOR COOKING
====================================================

1. SYSTEM OVERVIEW
------------------
The project controls a 4-degree-of-freedom (4-DOF) robotic arm intended for cooking tasks. 
The architecture is split into two main components to maximize flexibility and debuggability:
   A. PC-SIDE (Brain): Python based GUI & Kinematics Engine.
   B. MCU-SIDE (Muscle): ESP32 Firmware acting as a hardware driver.

This separation allows for complex math and logging to happen on a powerful computer, 
while the ESP32 focuses solely on generating precise PWM signals.

2. HARDWARE ARCHITECTURE
------------------------
- **Controller**: ESP32 Development Board.
- **Actuators**: 
  - J1, J2, J3: TD-8120MG High Torque Servos (270° Range).
  - J4: MG90S Micro Servo (180° Range).
- **Connection**: USB Serial (UART) between PC and ESP32 at 115200 baud.
- **Power**: Servos should be powered by an external 5V-6V High Current supply, sharing GND with ESP32.

Pinout Configuration (Current):
- Servo 1 (Base/Waist) : GPIO 13
- Servo 2 (Shoulder)   : GPIO 14
- Servo 3 (Elbow)      : GPIO 22
- Servo 4 (Wrist/Tool) : GPIO 23

3. FIRMWARE (ESP32)
-------------------
**File:** `ESP32_FIRMWARE/simple_servo_control.ino`
**Role:** "Dumb" Driver.
**Logic:**
- It initializes 4 servo objects.
- It listens on the Serial port for text commands ending in a newline (`\n`).
- It parses these commands and updates the servo pulse width immediately.
- It does NOT perform any kinematics or geometric calculations.
- It enforces safety limits (Min Pulse: 500us, Max Pulse: 2500us).

**Communication Protocol:**
- **Command Format:** `s[ServoIndex]-[PulseWidth]`
  - `s1-1500`  -> Sets Servo 1 to 1500 microseconds.
  - `s3-600`   -> Sets Servo 3 to 600 microseconds.
  - `set`      -> Special command to center all servos to 1500us.
- **Feedback:** The ESP32 prints acknowledgement messages like `>> Servo 1 moved to 1500µs`.

4. SOFTWARE (PYTHON CONTROL)
----------------------------
**File:** `Slider control with Forward kinematics/driver_gui.py` (and `visualize_robot.py`)
**Dependencies:** `tkinter`, `pyserial`, `numpy`, `matplotlib`
**Role:** The "Brain" - User Interface, Math, and Command Sender.

**Modules:**
A. **GUI (Graphical User Interface):**
   - Sliders for manual control (500-2500us).
   - Handles Serial connection.
   - Displays real-time logs and calculated XYZ positions.

B. **Kinematics Engine:**
   - **Input:** Current Pulse Widths.
   - **Process:** 
     1. Pulse -> Angle: using confirmed scale factors (0.135°/us for 270° servos).
     2. Angle -> Pose: using **Homogenous Transformation Matrices** (4x4).
   - **Output:** X, Y, Z coordinates of the tool tip.

C. **Visualizer (`visualize_robot.py`):**
   - A "Digital Twin" of the robot to verify geometric assumptions before writing control code.

7. KINEMATICS & GEOMETRY (Detailed Findings)
--------------------------------------------
A. Geometric Model Validation
   - A 3D visualization tool was created, and the user confirmed it matches the physical robot.
   - **Conclusion:** The robot acts as a chain of offset joints (not planar). Simple trigonometry (Law of Cosines) is insufficient/inaccurate. We will use Matrix Kinematics.
   - **Measurement Strategy:** The user is using STL files and Fusion 360's "Mesh Section Sketch" feature to extract the Theoretical Design Dimensions ($L_1, L_2$, Offsets), which is more accurate than physical caliper measurement.

B. Joint 4 (Wrist) Complexity
   - J4 rotates around the Z-axis (relative to the forearm).
   - The Tool Tip is offset in X, Y, and Z relative to the J4 axis.
   - **Critical Implication:** J4 is NOT just an orientation motor. Because of the offset, rotating J4 causes the tool tip to **orbit** in a circle. This changes the X,Y coordinates of the tip.
   - The IK solver must account for this "Orbital" behavior.

C. Servo Characteristics
   - **J1, J2, J3 (TD-8120MG):** 
     - Range: 270 degrees.
     - Scale Factor: **0.135 degrees/us**.
   - **J4 (MG90S):**
     - Range: 180 degrees.
     - Scale Factor: **0.09 degrees/us**.
     - Note: This was identified during testing where J4 angles were significantly overestimated by the 270-degree logic.

D. Calibration Strategy (Zeroing)
   - **Mechanical Zero:** The arm is assembled "roughly vertical" at neutral (1500us).
   - **Software Zero:** We will define "Angle 0" as the Perfect Vertical Pose.
   - **Procedure:**
     1. User uses GUI to jog robot until it is perfectly vertical (measured with square ruler).
     2. Validates J2 and J3 are straight up.
     3. These specific Pulse Values are saved as `ZERO_OFFSET_PULSE`.
     4. `Angle = (CurrentPulse - ZERO_OFFSET_PULSE) * 0.135`.

E. Calibration Results (Jan 8, 2026 - Inverse Kinematic Implementation)
   **Phase 1: Angle Display Fix**
   - **Problem:** GUI showed 1526.3° for J2 when servo was at physical 0°
   - **Root Cause:** Incorrect DEFAULT_TRIMS and JOINT_OFFSETS from previous calibration
   - **Solution:** Reset both to zero and recalibrated from scratch
   - **Result:** Angles now display correctly
   
   **Phase 2: Trim Calibration (Pulse Width Level)**
   - **Goal:** Find pulse width where J2 is at true vertical (0°)
   - **Method:** Adjusted slider until physical servo was vertical
   - **Result:** J2 requires 1529µs to be at true 0°
   - **Configuration:** DEFAULT_TRIMS[1] = 29
   - **Formula:** Neutral_Pulse = 1500 + 29 = 1529µs
   
   **Phase 3: Geometric Offset Calibration (Angle Level)**
   - **Problem:** When GUI shows 85.7° for J2, physical measurement shows 90° (horizontal)
   - **Problem:** At -90°, the calibration is accurate (no offset needed)
   - **Analysis:** This asymmetry suggests either:
     * Servo mounting isn't perfectly aligned with robot geometry
     * Physical construction has slight angular deviation
     * Mechanical compliance/flex at positive angles
   - **Solution:** Add JOINT_OFFSETS[1] = 4.3°
   - **Calculation:** Physical_Angle - GUI_Angle = 90.0 - 85.7 = 4.3°
   - **Formula:** Final_Angle = (Calculated_Angle × Direction) + Offset
   - **Result:** GUI now reads 90.0° when physical measurement confirms horizontal
   
   **Understanding the Two-Stage Calibration:**
   1. **DEFAULT_TRIMS** (Stage 1): Shifts the pulse-to-angle conversion neutral point
      - Works at the pulse width level (microseconds)
      - Corrects for servo centering variations
      - J2 Example: 1529µs is true mechanical zero, not 1500µs
      
   2. **JOINT_OFFSETS** (Stage 2): Compensates for geometric misalignment
      - Works at the angle level (degrees)
      - Corrects for mounting angles or design deviations
      - J2 Example: +4.3° added to account for geometric reality vs. ideal model
   
   **Final J2 Calibration:**
   - DEFAULT_TRIMS[1] = 29 (pulse width correction)
   - JOINT_OFFSETS[1] = 4.3 (geometric correction)
   - JOINT_DIRECTIONS[1] = 1 (normal direction)
   
   **Trade-off and Precision Limitation:**
   - With JOINT_OFFSETS[1] = 4.3°, the +90° position is accurate
   - However, this offset causes -90° to read incorrectly (now reads ~-85.7°)
   - **Root Cause:** The physical robot exhibits asymmetric behavior - likely due to:
     * Mechanical compliance/flex under gravity (arm weight pulls differently at +90° vs -90°)
     * Servo mounting angle not perfectly perpendicular to rotation axis
     * Structural deflection or joint play that varies with direction
   - **Practical Solution:** For maximum precision in inverse kinematics operations:
     * **AVOID negative J2 angles** (below 0°)
     * **USE positive J2 angles only** (0° to +90° range)
     * This ensures kinematics accuracy matches physical reality
     * Trade-off accepted: Workspace is reduced but precision is maintained
   - **Alternative (not implemented):** Could use non-linear calibration curves or 
     direction-dependent offsets, but adds complexity for marginal benefit
